# 缓存

`Guava Cache` 是单个应用运行时的本地缓存。它不把数据存放到文件或外部服务器。

## 适用性

使用 `ConcurrentHashMap` 有更好的内存效率

但是 `Guava Cache` 有更多缓存实用特性

## 一、主要特性

### 1.加载

实用 `CacheBuilder.newBuilder()` 创建缓存

#### 1.1自动加载

CacheLoader和Callable通过这两种方法创建的cache，这两种方法都实现了一种逻辑——从缓存中取key X的值，如果该值已经缓存过了，则返回缓存中的值，如果没有缓存过，可以通过某个方法来获取这个值。

==注：== 使用getIfPresent方法获取数据，不会实现自动加载数据的效果。

##### 1.1.1 CacheLoader

在创建缓存的时候，定义`CacheLoader`，实现`load`方法，在使用 `get` 方法时候，实现自动加载的效果。

##### 1.1.2 Callable

在创建缓存的时候，不定义`CacheLoader`，在使用 `get` 方法时候使用 `get(K, Callable<V>)`方法。

#### 1.2手动加载

`cache.put(key, value)`

### 2.移除（回收）

==清理什么时候发生？==

使用CacheBuilder构建的缓存不会"自动"执行清理和回收工作，也不会在某个缓存项过期后马上清理，也没有诸如此类的清理机制。相反，它会在写操作时顺带做少量的维护工作，或者偶尔在读操作时做——如果写操作实在太少的话。

这样做的原因在于：如果要自动地持续清理缓存，就必须有一个线程，这个线程会和用户操作竞争共享锁。此外，某些环境下线程创建可能受限制，这样CacheBuilder就不可用了。

相反，我们把选择权交到你手里。如果你的缓存是高吞吐的，那就无需担心缓存的维护和清理等工作。如果你的 缓存只会偶尔有写操作，而你又不想清理工作阻碍了读操作，那么可以创建自己的维护线程，以固定的时间间隔调用Cache.cleanUp()。ScheduledExecutorService可以帮助你很好地实现这样的定时调度。

#### 2.1基于容量的回收（size-based eviction）

- 使用CacheBuilder.maximumSize(long)，规定缓存项的数目不超过固定值。
- 用CacheBuilder.maximumWeight(long)指定最大总重，用CacheBuilder.weigher(Weigher)指定一个权重函数，权重越大的项，越先被回收

==警告：== 在缓存项的数目达到限定值之前，缓存就可能进行回收操作——通常来说，这种情况发生在缓存项的数目逼近限定值时。

#### 2.2定时回收（Timed Eviction）

- expireAfterAccess(long, TimeUnit)：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。
- expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。

#### 2.3基于引用的回收（Reference-based Eviction）

- CacheBuilder.weakKeys()：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（`==`），使用弱引用键的缓存用==而不是equals比较键。
- CacheBuilder.weakValues()：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。因为垃圾回收仅依赖恒等式（`==`），使用弱引用值的缓存用==而不是equals比较值。
- CacheBuilder.softValues()：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。考虑到使用软引用的性能影响，我们通常建议使用更有性能预测性的缓存大小限定（见上文，基于容量回收）。使用软引用值的缓存同样用==而不是equals比较值。

#### 2.4显式清除

- 个别清除：Cache.invalidate(key)
- 批量清除：Cache.invalidateAll(keys)
- 清除所有缓存项：Cache.invalidateAll()

### 3.移除监听

通过CacheBuilder.removalListener(RemovalListener)，你可以声明一个监听器，以便缓存项被移除时做一些额外操作。缓存项被移除时，RemovalListener会获取移除通知[RemovalNotification]，其中包含移除原因[RemovalCause]、键和值。

请注意，RemovalListener抛出的任何异常都会在记录到日志后被丢弃[swallowed]。

==警告：== 默认情况下，监听器方法是在移除缓存时同步调用的。因为缓存的维护和请求响应通常是同时进行的，代价高昂的监听器方法在同步模式下会拖慢正常的缓存请求。在这种情况下，你可以使用RemovalListeners.asynchronous(RemovalListener, Executor)把监听器装饰为异步操作。

### 4.刷新

刷新和回收不太一样。正如LoadingCache.refresh(K)所声明，刷新表示为键加载新值，这个过程可以是异步的。在刷新操作进行时，缓存仍然可以向其他线程返回旧值，而不像回收操作，读缓存的线程必须等待新值加载完成。

如果刷新过程抛出异常，缓存将保留旧值，而异常会在记录到日志后被丢弃[swallowed]。

重载CacheLoader.reload(K, V)可以扩展刷新时的行为，这个方法允许开发者在计算新值时使用旧的值。

CacheBuilder.refreshAfterWrite(long, TimeUnit)可以为缓存增加自动定时刷新功能。和expireAfterWrite相反，refreshAfterWrite通过定时刷新可以让缓存项保持可用，但请注意：缓存项只有在被检索时才会真正刷新（如果CacheLoader.refresh实现为异步，那么检索不会被刷新拖慢）。因此，如果你在缓存上同时声明expireAfterWrite和refreshAfterWrite，缓存并不会因为刷新盲目地定时重置，如果缓存项没有被检索，那刷新就不会真的发生，缓存项在过期时间后也变得可以回收。

## 二、其他特性

### 统计

在构建`Cache`的时候增加`.recordStats()`方法，则可以统计数据

获取统计数据`CacheStats cacheStats = cache.stats();`

有以下方法可以使用

方法名 | 描述
---|---
requestCount() | 返回Cache的lookup方法查找缓存的次数，不论查找的值是否被缓存。
hitCount() | 返回Cache的lookup方法命中缓存的次数。
hitRate() | 返回缓存请求的命中率，命中次数除以请求次数。
missCount() | 返回缓存请求的未命中的次数。
missRate() | 返回缓存请求未命中的比率，未命中次数除以请求次数。
loadCount() | 返回缓存调用load方法加载新值的次数。
loadSuccessCount() | 返回缓存加载新值的成功次数。
loadExceptionCount() | 返回缓存加载新值出现异常的次数。
loadExceptionRate() | 返回缓存加载新值出现异常的比率。 
totalLoadTime() | 返回缓存加载新值所耗费的总时间。
averageLoadPenalty() | 缓存加载新值的耗费的平均时间，加载的次数除以加载的总时间。
evictionCount() | 返回缓存中条目被移除的次数。
minus(CacheStats other) | 返回一个新的表示当前CacheStats与传入CacheStats之间差异的CacheStats实例。
plus(CacheStats other) | 返回一个新的表示当前CacheStats与传入CacheStats之间总计的CacheStats实例。

### asMap视图

asMap视图提供了缓存的ConcurrentMap形式，但asMap视图与缓存的交互需要注意：

- cache.asMap()包含当前所有加载到缓存的项。因此相应地，cache.asMap().keySet()包含当前所有已加载键;
- asMap().get(key)实质上等同于cache.getIfPresent(key)，而且不会引起缓存项的加载。这和Map的语义约定一致。
- 所有读写操作都会重置相关缓存项的访问时间，包括Cache.asMap().get(Object)方法和Cache.asMap().put(K, V)方法，但不包括Cache.asMap().containsKey(Object)方法，也不包括在Cache.asMap()的集合视图上的操作。比如，遍历Cache.asMap().entrySet()不会重置缓存项的读取时间。

### 中断